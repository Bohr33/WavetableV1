#Fixing Aliasing

The current state of the plugin loads wavetable's generated by my simple, custom wavetable generator. It is currently generating wavetables of simple shapes, with an arbitrary number of harmonics. While this is fine for early development, this implementation runs into issues. Notes of higher frequencies will eventually cause aliasing from naive implementation.


##Mipmaps
To solve this issue, many production level digital wavetables synths employ mipmaps. Mipmaps are copies of the generated table in question, but which are filtered to eliminate the unwanted frequency. It is standard for a synth to employ 1-2 mipmaps per octave, interpolating or switching bewteen them as the user plays higher frequencies.

##Oversampling
I've seen some discussion online about using oversampling as another means to eliminate aliasing. This would involve not only creating mip-maps, but running the wavetables at twice their normal rate, and applying a filtering process afterwards. Other users pointed out however that this is not entirely necessary; employing enough mipmaps seems to be sufficient enough.


##Filter via FFT
The overall goal for our new wavetable function will be to take an abitrary wavetable, and create mipmaps of relevant harmonics, filtering out harmonics when necessary. To do this, we can use a Fast-Fourier Transform, then zero unecessary bins as needed, and then use an IFT. This is a common method employed by larger companies such as Serum and Vital (Claude Code lol). Since my project currently has an additive generator for basic shapes, I could bypass this step and just create mipmaps directly, however my eventually goal will be to expand on these wavetables with arbitrary shapes, so employing a contained wavetable generator to generator these mipmaps now will be proactive move.



###Solution Moving Forward
Currently, the wavetables being generated contain 2048 samples, with a guard point, but as mentioned earlier, an arbitrary number of harmonics, leading to an unctrollable situation for later wavetables.

The solution to this will be adapting the current wavetable model to create and utilize mipmaps. Currently, the wavetables are being generated as basic tables. Since it is convinient to work with tables like this, the ideal solution for generating bitmaps will receive these tables, with or without guard points, and then create a set of mipmaps.



### Questions/Concerns
- MipMap management: how will the mipmaps be managed? Eventually we will want these to be saved and re-loaded once we have enough wavetables for this to be necessary, however for now, simply re-generating these on initialization should suffice.


###Outline
- Create new class for generating / managing mipmaps
- Need to outline format for mipmaps structure
	- Will need array of arrays
		- Option 1: contiguous memory, best for efficiency
		- Option 2: vector of vectors, simple conceptually, doesn't take much management
		- Option 3: Custom structure for manage, will contain some type of vector or span structure
		
	- I will opt for option 2 for now.

- Necessary Functions
	- Generate MipMap from wavetable
		- Turn wavetable into mipmaps and store
			- FFT the wavetable, filter, IFT

	
	
###MIDI Boundaries
When generating MipMaps, you must pay attention to the range of midi notes you are generating mipmaps for, and for how many octaves you are doing so. The standard layout for this is to generate mip maps for the entire MIDI range (0 -127) and in octave incremenets. Thus we can define some useful parameters for this below.

$$
\text{Full MIDI Range} = \text{C}_{-1} - \text{G}_{9}, 8.18 Hz - 12543 Hz  
$$
For each octave, we will want to use the highest note in the octave to determine our maximum frequencies, this will be B, except for the last octave where the final value is G. Since we will want a loop to generate these MIDI maps, keeping this minimum value for B in mind will be useful for a loop counter.

$$
\text{Loop Octave Max Frequency Mimumum} = \text{B}_{1}, 15.434 Hz
$$


